using Cocona;
using AIKeyMouse.CodeGen.CLI.Commands;
using AIKeyMouse.CodeGen.CLI.Models.LLM;
using AIKeyMouse.CodeGen.CLI.Services.Infrastructure;
using AIKeyMouse.CodeGen.CLI.Services.LLM;
using AIKeyMouse.CodeGen.CLI.Services.Skills;
using AIKeyMouse.CodeGen.CLI.Services.Parsers;
using AIKeyMouse.CodeGen.CLI.Services.CodeGeneration;
using Microsoft.Extensions.Logging;

namespace AIKeyMouse.CodeGen.CLI.Commands;

/// <summary>
/// Command for generating Step Definition classes
/// </summary>
public class StepsCommand : BaseCommand
{
    private readonly LlmProviderFactory _llmFactory;
    private readonly SkillLoader _skillLoader;
    private readonly PromptBuilder _promptBuilder;
    private readonly GherkinParser _gherkinParser;
    private readonly CodeGenerator _codeGenerator;

    public StepsCommand(
        ILogger<StepsCommand> logger,
        ConfigurationService configService,
        FileService fileService,
        LlmProviderFactory llmFactory,
        SkillLoader skillLoader,
        PromptBuilder promptBuilder,
        GherkinParser gherkinParser,
        CodeGenerator codeGenerator)
        : base(logger, configService, fileService)
    {
        _llmFactory = llmFactory;
        _skillLoader = skillLoader;
        _promptBuilder = promptBuilder;
        _gherkinParser = gherkinParser;
        _codeGenerator = codeGenerator;
    }

    /// <summary>
    /// Generate step definitions from a feature file
    /// </summary>
    public async Task<int> ExecuteAsync(
        [Option('f', Description = "Feature file path")] string feature,
        [Option('o', Description = "Output directory")] string? output = null,
        [Option("ns", Description = "Root namespace (defaults to StepDefinitions)")] string? rootNamespace = null,
        [Option('s', Description = "Skill file path")] string? skillPath = null,
        [Option('p', Description = "Comma-separated page object names")] string? pages = null,
        [Option("platform", Description = "Platform (web, mobile, desktop)")] string platform = "web",
        [Option("scenario", Description = "Specific scenario name to generate")] string? scenarioName = null)
    {
        DisplayInfo($"Generating Step Definitions from: {feature}");

        try
        {
            // Parse feature file
            DisplayInfo("Parsing feature file...");
            var parsedFeature = await _gherkinParser.ParseFeatureFileAsync(feature);
            
            DisplaySuccess($"✓ Parsed feature: {parsedFeature.Name}");
            DisplayInfo($"  Scenarios: {parsedFeature.Scenarios.Count}");

            // Load skill
            var skill = await LoadSkillAsync(skillPath, platform);

            // Determine namespace
            var namespaceToUse = rootNamespace ?? "StepDefinitions";
            
            // Build context for prompt
            var context = new Dictionary<string, object>
            {
                ["featureName"] = parsedFeature.Name,
                ["platform"] = platform,
                ["namespace"] = namespaceToUse,
                ["rootNamespace"] = namespaceToUse,
                ["gherkinSteps"] = _gherkinParser.GetStepsAsText(parsedFeature, scenarioName)
            };

            if (!string.IsNullOrWhiteSpace(scenarioName))
            {
                context["scenario"] = scenarioName;
            }

            // Parse and add page objects with methods
            var pageObjects = await ParsePageObjectsAsync(pages, parsedFeature);
            if (pageObjects.Count > 0)
            {
                context["pages"] = pageObjects;
                DisplayInfo($"  Page objects: {string.Join(", ", pageObjects.Select(p => p["name"]))}");
            }
            
            // Parse feature for table structures
            var tableDataClasses = ParseTableStructures(parsedFeature, scenarioName);
            if (tableDataClasses.Count > 0)
            {
                context["tableDataClasses"] = tableDataClasses;
                DisplayInfo($"  Data classes: {tableDataClasses.Count}");
            }

            // Build prompt
            DisplayInfo("Building prompt from skill template...");
            var userPrompt = await _promptBuilder.BuildPromptAsync(skill, context);
            var systemPrompt = _promptBuilder.BuildSystemMessage(skill);

            // Generate code using LLM
            DisplayInfo($"Generating code using {skill.Name}...");
            var llmRequest = new LlmRequest
            {
                Prompt = userPrompt,
                SystemMessage = systemPrompt,
                Temperature = (float)(skill.LlmParams?.Temperature ?? Config.Llm.Temperature),
                MaxTokens = skill.LlmParams?.MaxTokens ?? Config.Llm.MaxTokens
            };

            var response = await _llmFactory.GenerateWithFailoverAsync(llmRequest);
            
            DisplayInfo($"✓ Generated by {response.Provider} ({response.Model}) - {response.TotalTokens} tokens");

            // Extract code from response
            var code = _promptBuilder.ExtractCode(response.Content, skill.Output?.CodeExtraction);

            // Add required using statements
            if (skill.Validation?.RequiredUsings != null && skill.Validation.RequiredUsings.Count > 0)
            {
                code = _codeGenerator.AddUsings(code, skill.Validation.RequiredUsings);
            }

            // Format code if enabled
            if (skill.Validation?.AutoFormat ?? Config.CodeGeneration.AutoFormat)
            {
                DisplayInfo("Formatting code...");
                code = _codeGenerator.FormatCode(code);
            }

            // Validate syntax if enabled
            if (skill.Validation?.ValidateSyntax ?? Config.CodeGeneration.ValidateSyntax)
            {
                DisplayInfo("Validating syntax...");
                var (isValid, errors) = _codeGenerator.ValidateSyntax(code);
                
                if (!isValid)
                {
                    DisplayWarning($"Code has {errors.Count} syntax error(s):");
                    foreach (var error in errors)
                    {
                        DisplayError($"  {error}");
                    }
                    
                    if (!await ConfirmActionAsync("Continue with syntax errors?"))
                    {
                        return 1;
                    }
                }
                else
                {
                    DisplaySuccess("✓ Syntax validation passed");
                }
            }

            // Determine output path
            var outputDir = output ?? skill.Output?.DefaultPath ?? "StepDefinitions";
            var fileNamePattern = skill.Output?.FileNamePattern ?? "{name}Steps.cs";
            var fileName = fileNamePattern.Replace("{name}", parsedFeature.Name);
            var outputPath = Path.Combine(outputDir, fileName);

            // Write file
            await FileService.WriteFileAsync(outputPath, code);
            
            DisplaySuccess($"✓ Step definitions generated: {outputPath}");
            DisplayInfo($"Class: {_codeGenerator.GetClassName(code)}");
            DisplayInfo($"Namespace: {_codeGenerator.GetNamespace(code)}");

            return 0;
        }
        catch (Exception ex)
        {
            DisplayError($"Failed to generate step definitions: {ex.Message}");
            Logger.LogError(ex, "Step generation failed");
            return 1;
        }
    }

    private async Task<Models.Skills.Skill> LoadSkillAsync(string? skillPath, string platform)
    {
        if (!string.IsNullOrWhiteSpace(skillPath))
        {
            DisplayInfo($"Loading custom skill from: {skillPath}");
            return await _skillLoader.LoadSkillAsync(skillPath);
        }

        // Load built-in skill based on platform
        var builtInSkillPath = platform.ToLowerInvariant() switch
        {
            "web" => Path.Combine(AppContext.BaseDirectory, "Skills", "StepDefinitions", "step-definition-web.skill.md"),
            "mobile" => Path.Combine(AppContext.BaseDirectory, "Skills", "StepDefinitions", "step-definition-mobile.skill.json"),
            "desktop" => Path.Combine(AppContext.BaseDirectory, "Skills", "StepDefinitions", "step-definition-desktop.skill.json"),
            _ => throw new ArgumentException($"Unsupported platform: {platform}")
        };

        DisplayInfo($"Using built-in {platform} step definition skill");
        return await _skillLoader.LoadSkillAsync(builtInSkillPath);
    }

    private async Task<List<Dictionary<string, object>>> ParsePageObjectsAsync(string? pageNames, Models.Parsing.ParsedFeature feature)
    {
        var result = new List<Dictionary<string, object>>();
        
        // Get page names from parameter or extract from feature
        var pages = new List<string>();
        if (!string.IsNullOrWhiteSpace(pageNames))
        {
            pages = pageNames.Split(',', StringSplitOptions.RemoveEmptyEntries)
                .Select(p => p.Trim())
                .ToList();
        }
        else
        {
            pages = _gherkinParser.ExtractPageObjectNames(feature);
        }

        foreach (var pageName in pages)
        {
            var pageInfo = new Dictionary<string, object>
            {
                ["name"] = pageName,
                ["methodsFound"] = false,
                ["methods"] = new List<Dictionary<string, object>>()
            };

            // Try to find page object file
            var pageFiles = await FileService.FindFilesAsync($"Pages/**/{pageName}Page.cs");
            if (pageFiles.Any())
            {
                var pageFile = pageFiles.First();
                DisplayInfo($"  Found page file: {pageFile}");
                
                var methods = await ParsePageMethodsAsync(pageFile);
                if (methods.Count > 0)
                {
                    pageInfo["methodsFound"] = true;
                    pageInfo["methods"] = methods;
                    DisplayInfo($"    Extracted {methods.Count} methods");
                }
            }
            else
            {
                DisplayInfo($"  Page file not found for {pageName}, will use method inference");
            }

            result.Add(pageInfo);
        }

        return result;
    }

    private async Task<List<Dictionary<string, object>>> ParsePageMethodsAsync(string filePath)
    {
        var methods = new List<Dictionary<string, object>>();
        var content = await FileService.ReadFileAsync(filePath);
        
        // Regex to match public methods with return types, names, and parameters
        // Supports generics like List<T>, Task<IWebElement>, etc.
        var methodPattern = @"public\s+([\w<>\[\],\s]+)\s+(\w+)\s*\(([^)]*)\)";
        var matches = System.Text.RegularExpressions.Regex.Matches(content, methodPattern);

        foreach (System.Text.RegularExpressions.Match match in matches)
        {
            var returnType = match.Groups[1].Value.Trim();
            var methodName = match.Groups[2].Value.Trim();
            var parametersStr = match.Groups[3].Value.Trim();

            var parameters = new List<Dictionary<string, string>>();
            if (!string.IsNullOrWhiteSpace(parametersStr))
            {
                var paramParts = parametersStr.Split(',');
                foreach (var param in paramParts)
                {
                    var parts = param.Trim().Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                    if (parts.Length >= 2)
                    {
                        parameters.Add(new Dictionary<string, string>
                        {
                            ["type"] = string.Join(" ", parts.Take(parts.Length - 1)),
                            ["name"] = parts.Last()
                        });
                    }
                }
            }

            methods.Add(new Dictionary<string, object>
            {
                ["returnType"] = returnType,
                ["name"] = methodName,
                ["parameters"] = parameters
            });
        }

        return methods;
    }

    private List<Dictionary<string, object>> ParseTableStructures(Models.Parsing.ParsedFeature feature, string? scenarioName)
    {
        var dataClasses = new List<Dictionary<string, object>>();
        var processedStructures = new HashSet<string>();

        var scenariosToProcess = string.IsNullOrWhiteSpace(scenarioName)
            ? feature.Scenarios
            : feature.Scenarios.Where(s => s.Name == scenarioName).ToList();

        foreach (var scenario in scenariosToProcess)
        {
            foreach (var step in scenario.Steps)
            {
                // Check if step text indicates a table (ends with colon)
                if (step.Text.TrimEnd().EndsWith(":"))
                {
                    // Extract table columns - this would need actual table data from Gherkin parser
                    // For now, we'll create a placeholder
                    var className = GenerateDataClassName(step.Text);
                    var structureKey = className;

                    if (!processedStructures.Contains(structureKey))
                    {
                        // In a real implementation, we'd parse actual table columns here
                        // For now, create a placeholder structure
                        dataClasses.Add(new Dictionary<string, object>
                        {
                            ["className"] = className,
                            ["properties"] = new List<Dictionary<string, string>>()
                        });
                        processedStructures.Add(structureKey);
                    }
                }
            }
        }

        return dataClasses;
    }

    private string GenerateDataClassName(string stepText)
    {
        // Remove common prefixes and convert to PascalCase
        var cleaned = stepText
            .Replace("Given ", "")
            .Replace("When ", "")
            .Replace("Then ", "")
            .Replace("And ", "")
            .Replace("But ", "")
            .TrimEnd(':')
            .Trim();

        // Extract meaningful words and convert to PascalCase
        var words = cleaned.Split(new[] { ' ', '_', '-' }, StringSplitOptions.RemoveEmptyEntries);
        var className = string.Join("", words.Select(w => char.ToUpper(w[0]) + w.Substring(1).ToLower()));
        
        return className + "Data";
    }
}
