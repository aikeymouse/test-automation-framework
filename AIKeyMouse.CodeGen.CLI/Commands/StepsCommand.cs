using Cocona;
using AIKeyMouse.CodeGen.CLI.Commands;
using AIKeyMouse.CodeGen.CLI.Models.LLM;
using AIKeyMouse.CodeGen.CLI.Services.Infrastructure;
using AIKeyMouse.CodeGen.CLI.Services.LLM;
using AIKeyMouse.CodeGen.CLI.Services.Skills;
using AIKeyMouse.CodeGen.CLI.Services.Parsers;
using AIKeyMouse.CodeGen.CLI.Services.CodeGeneration;
using Microsoft.Extensions.Logging;

namespace AIKeyMouse.CodeGen.CLI.Commands;

/// <summary>
/// Command for generating Step Definition classes
/// </summary>
public class StepsCommand : BaseCommand
{
    private readonly LlmProviderFactory _llmFactory;
    private readonly SkillLoader _skillLoader;
    private readonly PromptBuilder _promptBuilder;
    private readonly GherkinParser _gherkinParser;
    private readonly CodeGenerator _codeGenerator;

    public StepsCommand(
        ILogger<StepsCommand> logger,
        ConfigurationService configService,
        FileService fileService,
        LlmProviderFactory llmFactory,
        SkillLoader skillLoader,
        PromptBuilder promptBuilder,
        GherkinParser gherkinParser,
        CodeGenerator codeGenerator)
        : base(logger, configService, fileService)
    {
        _llmFactory = llmFactory;
        _skillLoader = skillLoader;
        _promptBuilder = promptBuilder;
        _gherkinParser = gherkinParser;
        _codeGenerator = codeGenerator;
    }

    /// <summary>
    /// Generate step definitions from a feature file
    /// </summary>
    public async Task<int> ExecuteAsync(
        [Option('f', Description = "Feature file path")] string feature,
        [Option('o', Description = "Output directory")] string? output = null,
        [Option("namespace", Description = "Custom namespace")] string? customNamespace = null,
        [Option('s', Description = "Skill file path")] string? skillPath = null,
        [Option('p', Description = "Platform (web, mobile, desktop)")] string platform = "web",
        [Option("pages", Description = "Comma-separated page object names")] string? pages = null,
        [Option("scenario", Description = "Specific scenario name to generate")] string? scenarioName = null)
    {
        DisplayInfo($"Generating Step Definitions from: {feature}");

        try
        {
            // Parse feature file
            DisplayInfo("Parsing feature file...");
            var parsedFeature = await _gherkinParser.ParseFeatureFileAsync(feature);
            
            DisplaySuccess($"✓ Parsed feature: {parsedFeature.Name}");
            DisplayInfo($"  Scenarios: {parsedFeature.Scenarios.Count}");

            // Load skill
            var skill = await LoadSkillAsync(skillPath, platform);

            // Build context for prompt
            var context = new Dictionary<string, object>
            {
                ["featureName"] = parsedFeature.Name,
                ["platform"] = platform,
                ["namespace"] = customNamespace ?? Config.CodeGeneration.DefaultNamespace ?? "StepDefinitions",
                ["gherkinSteps"] = _gherkinParser.GetStepsAsText(parsedFeature, scenarioName)
            };

            if (!string.IsNullOrWhiteSpace(scenarioName))
            {
                context["scenario"] = scenarioName;
            }

            // Add page objects if provided
            if (!string.IsNullOrWhiteSpace(pages))
            {
                context["pageObjects"] = pages.Split(',', StringSplitOptions.RemoveEmptyEntries)
                    .Select(p => p.Trim())
                    .ToList();
            }
            else
            {
                // Try to extract from feature
                var extractedPages = _gherkinParser.ExtractPageObjectNames(parsedFeature);
                if (extractedPages.Count > 0)
                {
                    context["pageObjects"] = extractedPages;
                    DisplayInfo($"  Detected page objects: {string.Join(", ", extractedPages)}");
                }
            }

            // Build prompt
            DisplayInfo("Building prompt from skill template...");
            var userPrompt = await _promptBuilder.BuildPromptAsync(skill, context);
            var systemPrompt = _promptBuilder.BuildSystemMessage(skill);

            // Generate code using LLM
            DisplayInfo($"Generating code using {skill.Name}...");
            var llmRequest = new LlmRequest
            {
                Prompt = userPrompt,
                SystemMessage = systemPrompt,
                Temperature = (float)(skill.LlmParams?.Temperature ?? Config.Llm.Temperature),
                MaxTokens = skill.LlmParams?.MaxTokens ?? Config.Llm.MaxTokens
            };

            var response = await _llmFactory.GenerateWithFailoverAsync(llmRequest);
            
            DisplayInfo($"✓ Generated by {response.Provider} ({response.Model}) - {response.TotalTokens} tokens");

            // Extract code from response
            var code = _promptBuilder.ExtractCode(response.Content, skill.Output?.CodeExtraction);

            // Add required using statements
            if (skill.Validation?.RequiredUsings != null && skill.Validation.RequiredUsings.Count > 0)
            {
                code = _codeGenerator.AddUsings(code, skill.Validation.RequiredUsings);
            }

            // Format code if enabled
            if (skill.Validation?.AutoFormat ?? Config.CodeGeneration.AutoFormat)
            {
                DisplayInfo("Formatting code...");
                code = _codeGenerator.FormatCode(code);
            }

            // Validate syntax if enabled
            if (skill.Validation?.ValidateSyntax ?? Config.CodeGeneration.ValidateSyntax)
            {
                DisplayInfo("Validating syntax...");
                var (isValid, errors) = _codeGenerator.ValidateSyntax(code);
                
                if (!isValid)
                {
                    DisplayWarning($"Code has {errors.Count} syntax error(s):");
                    foreach (var error in errors)
                    {
                        DisplayError($"  {error}");
                    }
                    
                    if (!await ConfirmActionAsync("Continue with syntax errors?"))
                    {
                        return 1;
                    }
                }
                else
                {
                    DisplaySuccess("✓ Syntax validation passed");
                }
            }

            // Determine output path
            var outputDir = output ?? skill.Output?.DefaultPath ?? "StepDefinitions";
            var fileNamePattern = skill.Output?.FileNamePattern ?? "{name}Steps.cs";
            var fileName = fileNamePattern.Replace("{name}", parsedFeature.Name);
            var outputPath = Path.Combine(outputDir, fileName);

            // Write file
            await FileService.WriteFileAsync(outputPath, code);
            
            DisplaySuccess($"✓ Step definitions generated: {outputPath}");
            DisplayInfo($"Class: {_codeGenerator.GetClassName(code)}");
            DisplayInfo($"Namespace: {_codeGenerator.GetNamespace(code)}");

            return 0;
        }
        catch (Exception ex)
        {
            DisplayError($"Failed to generate step definitions: {ex.Message}");
            Logger.LogError(ex, "Step generation failed");
            return 1;
        }
    }

    private async Task<Models.Skills.Skill> LoadSkillAsync(string? skillPath, string platform)
    {
        if (!string.IsNullOrWhiteSpace(skillPath))
        {
            DisplayInfo($"Loading custom skill from: {skillPath}");
            return await _skillLoader.LoadSkillAsync(skillPath);
        }

        // Load built-in skill based on platform
        var builtInSkillPath = platform.ToLowerInvariant() switch
        {
            "web" => Path.Combine(AppContext.BaseDirectory, "Skills", "StepDefinitions", "step-definition-web.skill.md"),
            "mobile" => Path.Combine(AppContext.BaseDirectory, "Skills", "StepDefinitions", "step-definition-mobile.skill.json"),
            "desktop" => Path.Combine(AppContext.BaseDirectory, "Skills", "StepDefinitions", "step-definition-desktop.skill.json"),
            _ => throw new ArgumentException($"Unsupported platform: {platform}")
        };

        DisplayInfo($"Using built-in {platform} step definition skill");
        return await _skillLoader.LoadSkillAsync(builtInSkillPath);
    }
}
